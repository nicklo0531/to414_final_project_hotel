---
title: "metaDecTr"
output:
  html_document:
    toc: true
    toc_float: true
    toc_collapsed: true
    toc_depth: 3
    highlight: tango
    theme: lumen
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
```


```{r}
library(caret)
library(rpart)
library(rpart.plot)
library(C50)
library(randomForest)
library(e1071)
library(class)
```


```{r}
# --------------------------------------------------
# Load precomputed probabilities from first-level models
# --------------------------------------------------

setwd("../")
source("data/data_cleaning_splitting.R")
source("models/LogisticRegression.R")
source("models/KNN.R")
source("models/DecisionTree.R")
source("models/RandomForest.R")
source("models/SVM.R")

log_train_prob <- readRDS("RDS/log_train_prob.rds")
log_test_prob  <- readRDS("RDS/log_test_prob.rds")

knn_train_prob <- readRDS("RDS/knn_train_prob.rds")  # best specificity
knn_test_prob  <- readRDS("RDS/knn_test_prob.rds")

c50_train_prob <- readRDS("RDS/c50_train_prob.rds")
c50_test_prob  <- readRDS("RDS/c50_test_prob.rds")

rf_train_prob <- readRDS("RDS/rf_train_prob.rds")  # ntree=800
rf_test_prob  <- readRDS("RDS/rf_test_prob.rds")

svm_train_prob <- readRDS("RDS/svm_linear_train_prob.rds")
svm_test_prob  <- readRDS("RDS/svm_linear_test_prob.rds")

# Outcome
y_train <- df_train$is_canceled
y_test  <- df_test$is_canceled

# --------------------------------------------------
# Build stacked data frame for second-level model
# --------------------------------------------------

stack_train <- data.frame(
  log  = log_train_prob,
  knn  = knn_train_prob,
  c50  = c50_train_prob,
  rf   = rf_train_prob,
  svm  = svm_train_prob,
  is_canceled = y_train
)

stack_test <- data.frame(
  log = log_test_prob,
  knn = knn_test_prob,
  c50 = c50_test_prob,
  rf  = rf_test_prob,
  svm = svm_test_prob
)

length(log_train_prob)
length(knn_train_prob)
length(c50_train_prob)
length(rf_train_prob)
length(svm_train_prob)
length(y_train)
```


```{r}
# --------------------------------------------------
# Train second-level rpart (decision tree) on stacked probs
# --------------------------------------------------

set.seed(12345)
stack_dt <- rpart(
  is_canceled ~ .,
  data    = stack_train,
  method  = "class",
  control = rpart.control(cp = 0.01)
)

# Predict probabilities on test set
stack_pred_class <- predict(stack_dt, stack_test, type = "class")
stack_pred_prob  <- predict(stack_dt, stack_test, type = "prob")[, "1"]

# Evaluate
stack_cm  <- confusionMatrix(stack_pred_class, y_test)
stack_roc <- pROC::roc(y_test, stack_pred_prob)
stack_auc <- pROC::auc(stack_roc)

# Plot tree
rpart.plot(stack_dt)

# Output metrics
stack_cm
stack_auc


# Define cost matrix
cost_TN <- 0
cost_FN <- 500
cost_FP <- 1200
cost_TP <- 0
cost_matrix <- matrix(c(cost_TN, cost_FP,
                        cost_FN, cost_TP),   
                      nrow = 2, byrow = TRUE)

stack_dt_cost <- rpart(
  is_canceled ~ .,
  data    = stack_train,
  method  = "class",
  parms   = list(loss = cost_matrix),
  control = rpart.control(cp = 0.01)
)

# Predict on test set
stack_pred_class_cost <- predict(stack_dt_cost, stack_test, type = "class")
stack_pred_prob_cost  <- predict(stack_dt_cost, stack_test, type = "prob")[, "1"]

# Evaluate
stack_cm_cost  <- confusionMatrix(stack_pred_class_cost, y_test)
stack_roc_cost <- pROC::roc(y_test, stack_pred_prob_cost)
stack_auc_cost <- pROC::auc(stack_roc_cost)

# Plot tree
rpart.plot(stack_dt_cost)

# Output metrics
stack_cm_cost
stack_auc_cost

thresholds <- seq(0.01, 0.99, by = 0.01)
costs <- sapply(thresholds, function(t) {
  preds <- ifelse(stack_pred_prob >= t, 1, 0)
  FP <- sum(preds == 1 & y_test == 0)
  FN <- sum(preds == 0 & y_test == 1)
  cost_FP*FP + cost_FN*FN
})
best_threshold <- thresholds[which.min(costs)]

stack_pred_cost <- ifelse(stack_pred_prob >= best_threshold, 1, 0)
confusionMatrix(factor(stack_pred_cost, levels=c(0,1)), y_test, positive="1")
```


